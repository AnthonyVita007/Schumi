{% extends "base.html" %}

{% block title %}Monitoraggio {% if driver %}{{ driver.first_name }} {{ driver.last_name }}{% endif %} - Sistema di Gestione Autisti{% endblock %}

{% block additional_css %}
<!-- Removed chart.css since we're not using charts anymore -->
{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header">
    <div class="container">
        <div class="page-header-content">
            <div class="header-info">
                <h1 class="page-title">
                    Monitoraggio: 
                    {% if driver %}
                        <span class="driver-highlight">{{ driver.first_name }} {{ driver.last_name }}</span>
                    {% else %}
                        <span class="driver-highlight">Autista</span>
                    {% endif %}
                </h1>
                <p class="page-subtitle">Sessione di monitoraggio in tempo reale</p>
            </div>
            
            <div class="header-actions">
                <button id="startStopBtn" class="btn btn-primary">
                    <svg class="btn-icon start-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5,3 19,12 5,21 5,3"></polygon>
                    </svg>
                    <svg class="btn-icon stop-icon hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                    <span id="startStopText">Avvia Monitoraggio</span>
                </button>
                
                <a href="/drivers" class="btn btn-secondary">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="m15 18-6-6 6-6"></path>
                    </svg>
                    Torna agli Autisti
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Monitoring Content -->
<div class="container">
    <div class="webcam-section">
        <div class="webcam-header">
            <h3>Camera</h3>
            <div class="webcam-status">
                <span class="status-indicator" id="webcamStatus"></span>
                <span id="webcamStatusText">Inizializzazione...</span>
            </div>
        </div>
        
        <div class="webcam-container" id="webcamContainer">
            <video id="webcamVideo" class="webcam-video" autoplay playsinline muted></video>
            <!-- Canvas overlay for face detection box and emotion label -->
            <canvas id="overlayCanvas" class="overlay-canvas"></canvas>
            
            <!-- Camera initialization overlay (existing) -->
            <div id="webcamOverlay" class="webcam-overlay">
                <div class="webcam-message">
                    <div class="webcam-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                            <circle cx="12" cy="13" r="4"></circle>
                        </svg>
                    </div>
                    <p id="webcamMessageText">Inizializzazione webcam...</p>
                </div>
            </div>
            
            <!-- Idle state overlay -->
            <div id="overlayIdle" class="monitoring-overlay monitoring-overlay--idle" aria-hidden="false">
                <div class="monitoring-overlay__content">
                    <span class="monitoring-overlay__text">Monitoraggio disattivato</span>
                </div>
            </div>
            
            <!-- Loading state overlay -->
            <div id="overlayLoading" class="monitoring-overlay monitoring-overlay--loading" role="status" aria-live="assertive" aria-hidden="true">
                <div class="monitoring-overlay__content">
                    <div class="monitoring-spinner" aria-label="Caricamento del modello di computer vision in corso"></div>
                    <span class="monitoring-overlay__text">Caricamento del modello di computer vision…</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Error Modal -->
<div id="errorModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Errore</h2>
            <button class="modal-close" onclick="closeErrorModal()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="modal-body">
            <p id="errorMessage">Si è verificato un errore.</p>
        </div>
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="closeErrorModal()">OK</button>
        </div>
    </div>
</div>
{% endblock %}

{% block additional_js %}
<!-- Removed Chart.js since we're not using charts anymore -->
{% endblock %}

{% block page_init_js %}
// Monitor page specific initialization
const driverId = {{ driver.id if driver else 'null' }};
let isMonitoring = false;
let webcamStream = null;
let sessionStartTime = null;
let dataPointsCount = 0;

let updateInterval = null;
let overlayCanvas = null;
let overlayCtx = null;

// Initialize monitoring page
initializeMonitoringPage();

// Monitoring state management functions
function setMonitoringState(state) {
    const container = document.getElementById('webcamContainer');
    const overlayIdle = document.getElementById('overlayIdle');
    const overlayLoading = document.getElementById('overlayLoading');
    
    switch (state) {
        case 'idle':
            container.classList.remove('is-monitoring');
            overlayLoading.classList.remove('is-visible');
            overlayLoading.setAttribute('aria-hidden', 'true');
            overlayIdle.setAttribute('aria-hidden', 'false');
            break;
            
        case 'loading':
            container.classList.remove('is-monitoring');
            overlayIdle.setAttribute('aria-hidden', 'true');
            overlayLoading.classList.add('is-visible');
            overlayLoading.setAttribute('aria-hidden', 'false');
            break;
            
        case 'active':
            container.classList.add('is-monitoring');
            overlayLoading.classList.remove('is-visible');
            overlayLoading.setAttribute('aria-hidden', 'true');
            overlayIdle.setAttribute('aria-hidden', 'true');
            break;
    }
}

async function initializeMonitoringPage() {
    if (!driverId) {
        showError('ID autista non valido');
        return;
    }
    
    // Initialize in idle state
    setMonitoringState('idle');
    
    setupWebcam();
    setupOverlayCanvas();
    setupEventListeners();
}

function setupEventListeners() {
    // Start/Stop monitoring button
    document.getElementById('startStopBtn').addEventListener('click', toggleMonitoring);
}

async function setupWebcam() {
    const video = document.getElementById('webcamVideo');
    const overlay = document.getElementById('webcamOverlay');
    const statusIndicator = document.getElementById('webcamStatus');
    const statusText = document.getElementById('webcamStatusText');
    const messageText = document.getElementById('webcamMessageText');
    
    try {
        messageText.textContent = 'Richiesta accesso alla webcam...';
        
        webcamStream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = webcamStream;
        
        video.onloadedmetadata = () => {
            // Hide overlay when camera is ready
            overlay.classList.add('hidden');
            statusIndicator.classList.add('online');
            statusText.textContent = 'Camera attiva';
            messageText.textContent = '';
        };
        
        video.onerror = (error) => {
            console.error('Video error:', error);
            statusIndicator.classList.add('offline');
            statusText.textContent = 'Errore camera';
            messageText.textContent = 'Errore nell\'accesso alla webcam';
        };
        
    } catch (error) {
        console.error('Error accessing webcam:', error);
        statusIndicator.classList.add('offline');
        statusText.textContent = 'Camera non disponibile';
        messageText.textContent = 'Impossibile accedere alla webcam. Controlla i permessi.';
    }
}

function setupOverlayCanvas() {
    const video = document.getElementById('webcamVideo');
    overlayCanvas = document.getElementById('overlayCanvas');
    overlayCtx = overlayCanvas.getContext('2d');
    
    // Size canvas to video once metadata is available
    video.addEventListener('loadedmetadata', () => {
        overlayCanvas.width = video.videoWidth;
        overlayCanvas.height = video.videoHeight;
        
        // Match displayed size
        overlayCanvas.style.width = video.offsetWidth + 'px';
        overlayCanvas.style.height = video.offsetHeight + 'px';
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (video.videoWidth > 0) {
            overlayCanvas.style.width = video.offsetWidth + 'px';
            overlayCanvas.style.height = video.offsetHeight + 'px';
        }
    });
}

async function toggleMonitoring() {
    if (isMonitoring) {
        await stopMonitoring();
    } else {
        await startMonitoring();
    }
}

async function startMonitoring() {
    // Show loading state immediately when button is clicked
    setMonitoringState('loading');
    
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor/start`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            isMonitoring = true;
            sessionStartTime = Date.now();
            dataPointsCount = 0;
            
            // Transition to active state
            setMonitoringState('active');
            updateMonitoringUI();
            startDataCollection();
            
            showFlashMessage('Monitoraggio avviato con successo', 'success');
        } else {
            // On error, return to idle state
            setMonitoringState('idle');
            showError('Errore nell\'avvio del monitoraggio: ' + result.error);
        }
    } catch (error) {
        console.error('Error starting monitoring:', error);
        // On error, return to idle state
        setMonitoringState('idle');
        showError('Errore di connessione nell\'avvio del monitoraggio');
    }
}

async function stopMonitoring() {
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor/stop`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            isMonitoring = false;
            sessionStartTime = null;
            
            // Return to idle state
            setMonitoringState('idle');
            updateMonitoringUI();
            stopDataCollection();
            
            showFlashMessage('Monitoraggio interrotto', 'info');
        } else {
            showError('Errore nell\'interruzione del monitoraggio: ' + result.error);
        }
    } catch (error) {
        console.error('Error stopping monitoring:', error);
        showError('Errore di connessione nell\'interruzione del monitoraggio');
    }
}

function updateMonitoringUI() {
    const button = document.getElementById('startStopBtn');
    const buttonText = document.getElementById('startStopText');
    const startIcon = button.querySelector('.start-icon');
    const stopIcon = button.querySelector('.stop-icon');
    
    if (isMonitoring) {
        button.classList.remove('btn-primary');
        button.classList.add('btn-danger');
        buttonText.textContent = 'Interrompi Monitoraggio';
        startIcon.classList.add('hidden');
        stopIcon.classList.remove('hidden');
    } else {
        button.classList.remove('btn-danger');
        button.classList.add('btn-primary');
        buttonText.textContent = 'Avvia Monitoraggio';
        startIcon.classList.remove('hidden');
        stopIcon.classList.add('hidden');
    }
}

function startDataCollection() {
    updateInterval = setInterval(async () => {
        if (isMonitoring) {
            await captureAndAnalyzeFrame();
            updateSessionStats();
        }
    }, 1000); // 1 FPS
}

function stopDataCollection() {
    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }
}

async function captureAndAnalyzeFrame() {
    /**
     * Cattura un frame dalla webcam e lo invia al nuovo endpoint per l'analisi AI.
     * In caso di errore, fa fallback al metodo mock esistente.
     */
    try {
        const video = document.getElementById('webcamVideo');
        
        // Verifica che il video sia disponibile e in riproduzione
        if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
            console.warn('Video non disponibile, uso fallback mock');
            await collectEmotionData();
            return;
        }
        
        // Crea canvas offscreen per catturare il frame
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Imposta dimensioni del canvas 
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Disegna il frame corrente del video sul canvas
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Converti in data URL JPEG compresso (qualità 0.6 per ridurre payload)
        const dataURL = canvas.toDataURL('image/jpeg', 0.6);
        
        // Invia il frame al nuovo endpoint per l'analisi
        const response = await fetch(`/api/drivers/${driverId}/monitor/frame`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                image: dataURL
            })
        });
        
        const result = await response.json();
        
        if (result.success && result.data) {
            const data = result.data;
            dataPointsCount++;
            
            // Update canvas overlay
            updateCanvasOverlay(data);
            
            // Log informazioni aggiuntive se disponibili dall'analisi AI
            if (data.emotion && data.inferenceMs) {
                console.log(`Emozione rilevata: ${data.emotion} (${data.inferenceMs}ms)`);
            }
        } else {
            console.warn('Errore nell\'analisi del frame, uso fallback mock');
            await collectEmotionData();
        }
        
    } catch (error) {
        console.error('Errore nella cattura/analisi del frame:', error);
        // Fallback al metodo mock in caso di errore
        await collectEmotionData();
    }
}

async function collectEmotionData() {
    /**
     * Metodo fallback che usa l'endpoint mock esistente.
     * Mantenuto per retrocompatibilità e come fallback robusto.
     */
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor/data`);
        const result = await response.json();
        
        if (result.success) {
            const data = result.data;
            dataPointsCount++;
            
            // Update canvas overlay
            updateCanvasOverlay(data);
        }
    } catch (error) {
        console.error('Error collecting emotion data:', error);
    }
}

function updateCanvasOverlay(data) {
    if (!overlayCtx || !overlayCanvas) return;
    
    // Clear the canvas
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    
    // If there's a bounding box, draw it
    if (data.bbox && data.bbox.x !== undefined) {
        const { x, y, w, h } = data.bbox;
        
        // Draw bounding box rectangle
        overlayCtx.strokeStyle = '#22c55e'; // Green color
        overlayCtx.lineWidth = 2;
        overlayCtx.strokeRect(x, y, w, h);
        
        // Draw emotion label above the box
        if (data.emotion) {
            overlayCtx.fillStyle = '#22c55e';
            overlayCtx.font = '16px Arial';
            overlayCtx.fillText(data.emotion, x, Math.max(16, y - 10));
        }
    } else {
        // Debug: mostra comunque l’emozione in alto a sinistra quando non c’è bbox
        if (data.emotion) {
            const text = data.emotion;
            overlayCtx.font = '16px Arial';
            const metrics = overlayCtx.measureText(text);
            const pad = 6;
            const rectW = metrics.width + pad * 2;
            const rectH = 22;
            overlayCtx.fillStyle = 'rgba(255,255,255,0.9)';
            overlayCtx.fillRect(8, 8, rectW, rectH);
            overlayCtx.fillStyle = '#111827';
            overlayCtx.fillText(text, 8 + pad, 8 + rectH - 6);
        }
    }
    
    // Update emotion bars (no-op nella UI attuale)
    updateEmotionBars(data);
}

function updateEmotionBars(data) {
    // Emotion bars have been removed from the UI, but we keep this function
    // for compatibility and to prevent errors. It's now a no-op.
    const stressBar = document.getElementById('stressBar');
    const focusBar = document.getElementById('focusBar');
    const calmBar = document.getElementById('calmBar');
    
    if (stressBar && data.stress !== undefined) {
        stressBar.style.width = (data.stress * 100) + '%';
    }
    if (focusBar && data.focus !== undefined) {
        focusBar.style.width = (data.focus * 100) + '%';
    }
    if (calmBar && data.calm !== undefined) {
        calmBar.style.width = (data.calm * 100) + '%';
    }
}

function updateSessionStats() {
    if (!sessionStartTime) return;
    
    const now = Date.now();
    const sessionDuration = Math.floor((now - sessionStartTime) / 1000);
    
    // Stats opzionali in console
    console.log(`Session: ${sessionDuration}s, Data points: ${dataPointsCount}`);
}

function showError(message) {
    const errorModal = document.getElementById('errorModal');
    const errorMessage = document.getElementById('errorMessage');
    
    if (errorMessage) {
        errorMessage.textContent = message;
    }
    if (errorModal) {
        errorModal.classList.remove('hidden');
    }
}

function closeErrorModal() {
    const errorModal = document.getElementById('errorModal');
    if (errorModal) {
        errorModal.classList.add('hidden');
    }
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
    }
    
    if (isMonitoring) {
        stopMonitoring();
    }
});
{% endblock %}