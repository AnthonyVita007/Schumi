{% extends "base.html" %}

{% block title %}Monitoraggio {% if driver %}{{ driver.first_name }} {{ driver.last_name }}{% endif %} - Sistema di Gestione Autisti{% endblock %}

{% block additional_css %}
<!-- Removed chart.css since we're not using charts anymore -->
{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header">
    <div class="container">
        <div class="page-header-content">
            <div class="header-info">
                <h1 class="page-title">
                    Monitoraggio: 
                    {% if driver %}
                        <span class="driver-highlight">{{ driver.first_name }} {{ driver.last_name }}</span>
                    {% else %}
                        <span class="driver-highlight">Autista</span>
                    {% endif %}
                </h1>
                <p class="page-subtitle">Sessione di monitoraggio in tempo reale</p>
            </div>
            
            <div class="header-actions">
                <button id="startStopBtn" class="btn btn-primary">
                    <svg class="btn-icon start-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5,3 19,12 5,21 5,3"></polygon>
                    </svg>
                    <svg class="btn-icon stop-icon hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                    <span id="startStopText">Avvia Monitoraggio</span>
                </button>
                
                <a href="/drivers" class="btn btn-secondary">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="m15 18-6-6 6-6"></path>
                    </svg>
                    Torna agli Autisti
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Monitoring Content -->
<div class="monitoring-content">
    <div class="container">
        <div class="monitoring-grid">
            <!-- Webcam Feed Section -->
            <div class="webcam-section">
                <div class="section-card">
                    <div class="section-header">
                        <h2 class="section-title">
                            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                <circle cx="12" cy="13" r="4"></circle>
                            </svg>
                            Webcam Feed
                        </h2>
                        <div class="webcam-status">
                            <span class="status-indicator" id="webcamStatus"></span>
                            <span id="webcamStatusText">Inizializzazione...</span>
                        </div>
                    </div>
                    
                    <div class="webcam-container">
                        <video id="webcamVideo" class="webcam-video" autoplay playsinline muted></video>
                        <!-- Canvas overlay for face detection box and emotion label -->
                        <canvas id="overlayCanvas" class="overlay-canvas"></canvas>
                        <div id="webcamOverlay" class="webcam-overlay">
                            <div class="webcam-message">
                                <div class="webcam-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                        <circle cx="12" cy="13" r="4"></circle>
                                    </svg>
                                </div>
                                <p id="webcamMessageText">Inizializzazione webcam...</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Removed webcam controls as they are no longer needed -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Error Modal -->
<div id="errorModal" class="modal hidden">
    <div class="modal-overlay"></div>
    <div class="modal-content">
        <div class="modal-header">
            <h2>Errore</h2>
            <button class="modal-close" onclick="closeErrorModal()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="modal-body">
            <p id="errorMessage">Si è verificato un errore.</p>
        </div>
        <div class="modal-actions">
            <button class="btn btn-primary" onclick="closeErrorModal()">OK</button>
        </div>
    </div>
</div>
{% endblock %}

{% block additional_js %}
<!-- Removed Chart.js since we're not using charts anymore -->
{% endblock %}

{% block page_init_js %}
// Monitor page specific initialization
const driverId = {{ driver.id if driver else 'null' }};
let isMonitoring = false;
let webcamStream = null;
let sessionStartTime = null;
let dataPointsCount = 0;
let updateInterval = null;
let overlayCanvas = null;
let overlayCtx = null;

// Initialize monitoring page
initializeMonitoringPage();

async function initializeMonitoringPage() {
    if (!driverId) {
        showError('ID autista non valido');
        return;
    }
    
    setupWebcam();
    setupOverlayCanvas();
    setupEventListeners();
    
    // Load driver data
    await loadDriverData();
}

function setupEventListeners() {
    // Start/Stop monitoring button
    document.getElementById('startStopBtn').addEventListener('click', toggleMonitoring);
}

async function setupWebcam() {
    const video = document.getElementById('webcamVideo');
    const overlay = document.getElementById('webcamOverlay');
    const statusIndicator = document.getElementById('webcamStatus');
    const statusText = document.getElementById('webcamStatusText');
    const messageText = document.getElementById('webcamMessageText');
    
    try {
        messageText.textContent = 'Richiesta accesso alla webcam...';
        
        webcamStream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = webcamStream;
        
        video.onloadedmetadata = () => {
            overlay.classList.add('hidden');
            statusIndicator.className = 'status-indicator status-online';
            statusText.textContent = 'Connessa';
        };
        
    } catch (error) {
        console.error('Error accessing webcam:', error);
        
        let errorMessage = 'Impossibile accedere alla webcam.';
        if (error.name === 'NotAllowedError') {
            errorMessage = 'Accesso alla webcam negato. Controlla le autorizzazioni del browser.';
        } else if (error.name === 'NotFoundError') {
            errorMessage = 'Nessuna webcam trovata sul dispositivo.';
        }
        
        messageText.textContent = errorMessage;
        statusIndicator.className = 'status-indicator status-offline';
        statusText.textContent = 'Errore';
    }
}

function setupOverlayCanvas() {
    const video = document.getElementById('webcamVideo');
    overlayCanvas = document.getElementById('overlayCanvas');
    overlayCtx = overlayCanvas.getContext('2d');
    
    // Set canvas dimensions to match video when video loads
    video.addEventListener('loadedmetadata', () => {
        overlayCanvas.width = video.videoWidth;
        overlayCanvas.height = video.videoHeight;
        overlayCanvas.style.width = video.offsetWidth + 'px';
        overlayCanvas.style.height = video.offsetHeight + 'px';
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (video.videoWidth > 0) {
            overlayCanvas.style.width = video.offsetWidth + 'px';
            overlayCanvas.style.height = video.offsetHeight + 'px';
        }
    });
}

async function loadDriverData() {
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor`);
        const result = await response.json();
        
        if (result.success) {
            updateDriverInfo(result.data.driver);
        } else {
            showError('Errore nel caricamento dei dati dell\'autista: ' + result.error);
        }
    } catch (error) {
        console.error('Error loading driver data:', error);
        showError('Errore di connessione');
    }
}

function updateDriverInfo(driver) {
    document.getElementById('driverStatus').textContent = driver.monitoringStatus;
    document.getElementById('driverClassification').textContent = driver.classification;
}

async function toggleMonitoring() {
    if (isMonitoring) {
        await stopMonitoring();
    } else {
        await startMonitoring();
    }
}

async function startMonitoring() {
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor/start`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            isMonitoring = true;
            sessionStartTime = Date.now();
            dataPointsCount = 0;
            
            updateMonitoringUI();
            startDataCollection();
            
            showFlashMessage('Monitoraggio avviato con successo', 'success');
        } else {
            showError('Errore nell\'avvio del monitoraggio: ' + result.error);
        }
    } catch (error) {
        console.error('Error starting monitoring:', error);
        showError('Errore di connessione nell\'avvio del monitoraggio');
    }
}

async function stopMonitoring() {
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor/stop`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            isMonitoring = false;
            sessionStartTime = null;
            
            updateMonitoringUI();
            stopDataCollection();
            
            showFlashMessage('Monitoraggio interrotto', 'info');
        } else {
            showError('Errore nell\'interruzione del monitoraggio: ' + result.error);
        }
    } catch (error) {
        console.error('Error stopping monitoring:', error);
        showError('Errore di connessione nell\'interruzione del monitoraggio');
    }
}

function updateMonitoringUI() {
    const button = document.getElementById('startStopBtn');
    const buttonText = document.getElementById('startStopText');
    const startIcon = button.querySelector('.start-icon');
    const stopIcon = button.querySelector('.stop-icon');
    
    if (isMonitoring) {
        button.classList.remove('btn-primary');
        button.classList.add('btn-danger');
        buttonText.textContent = 'Interrompi Monitoraggio';
        startIcon.classList.add('hidden');
        stopIcon.classList.remove('hidden');
        
        document.getElementById('emotionOverlay').classList.remove('hidden');
    } else {
        button.classList.remove('btn-danger');
        button.classList.add('btn-primary');
        buttonText.textContent = 'Avvia Monitoraggio';
        startIcon.classList.remove('hidden');
        stopIcon.classList.add('hidden');
        
        document.getElementById('emotionOverlay').classList.add('hidden');
    }
}

function startDataCollection() {
    updateInterval = setInterval(async () => {
        if (isMonitoring) {
            await captureAndAnalyzeFrame();
            updateSessionStats();
        }
    }, 1000); // Update every 1 second (1 FPS) per specifiche - cambiabile facilmente
}

function stopDataCollection() {
    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }
}

async function captureAndAnalyzeFrame() {
    /**
     * Cattura un frame dalla webcam e lo invia al nuovo endpoint per l'analisi AI.
     * In caso di errore, fa fallback al metodo mock esistente.
     */
    try {
        const video = document.getElementById('webcamVideo');
        
        // Verifica che il video sia disponibile e in riproduzione
        if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
            console.warn('Video non disponibile, uso fallback mock');
            await collectEmotionData();
            return;
        }
        
        // Crea canvas offscreen per catturare il frame
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Imposta dimensioni del canvas 
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Disegna il frame corrente del video sul canvas
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Converti in data URL JPEG compresso (qualità 0.6 per ridurre payload)
        const dataURL = canvas.toDataURL('image/jpeg', 0.6);
        
        // Invia il frame al nuovo endpoint per l'analisi
        const response = await fetch(`/api/drivers/${driverId}/monitor/frame`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                image: dataURL
            })
        });
        
        const result = await response.json();
        
        if (result.success && result.data) {
            const data = result.data;
            dataPointsCount++;
            
            // Update canvas overlay invece di chart
            updateCanvasOverlay(data);
            
            // Log informazioni aggiuntive se disponibili dall'analisi AI
            if (data.emotion && data.inferenceMs) {
                console.log(`Emozione rilevata: ${data.emotion} (${data.inferenceMs}ms)`);
            }
        } else {
            console.warn('Errore nell\'analisi del frame, uso fallback mock');
            await collectEmotionData();
        }
        
    } catch (error) {
        console.error('Errore nella cattura/analisi del frame:', error);
        // Fallback al metodo mock in caso di errore
        await collectEmotionData();
    }
}

async function collectEmotionData() {
    /**
     * Metodo fallback che usa l'endpoint mock esistente.
     * Mantenuto per retrocompatibilità e come fallback robusto.
     */
    try {
        const response = await fetch(`/api/drivers/${driverId}/monitor/data`);
        const result = await response.json();
        
        if (result.success) {
            const data = result.data;
            dataPointsCount++;
            
            // Update canvas overlay
            updateCanvasOverlay(data);
        }
    } catch (error) {
        console.error('Error collecting emotion data:', error);
    }
}

function updateCanvasOverlay(data) {
    if (!overlayCtx || !overlayCanvas) return;
    
    // Clear the canvas
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    
    // If there's a bounding box, draw it
    if (data.bbox && data.bbox.x !== undefined) {
        const { x, y, w, h } = data.bbox;
        
        // Draw bounding box rectangle
        overlayCtx.strokeStyle = '#22c55e'; // Green color
        overlayCtx.lineWidth = 2;
        overlayCtx.strokeRect(x, y, w, h);
        
        // Draw emotion label with confidence if available
        if (data.emotion) {
            let label = data.emotion;
            
            // Add confidence percentage if probs are available
            if (data.probs) {
                const maxProb = Math.max(...Object.values(data.probs));
                const confidence = Math.round(maxProb * 100);
                label += ` (${confidence}%)`;
            }
            
            // Style the text
            overlayCtx.fillStyle = '#22c55e';
            overlayCtx.font = 'bold 16px Arial';
            overlayCtx.textAlign = 'left';
            
            // Draw text background for better readability
            const textMetrics = overlayCtx.measureText(label);
            const textHeight = 20;
            const padding = 4;
            
            overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            overlayCtx.fillRect(
                x, 
                y - textHeight - padding, 
                textMetrics.width + padding * 2, 
                textHeight + padding
            );
            
            // Draw the text
            overlayCtx.fillStyle = '#ffffff';
            overlayCtx.fillText(label, x + padding, y - padding);
        }
    }
    // If no bbox, the canvas remains clear (no face detected)
}

function updateSessionStats() {
    // Session duration and data points are no longer displayed in UI
    // but we keep the counter for internal tracking
    if (sessionStartTime) {
        const duration = Date.now() - sessionStartTime;
        const hours = Math.floor(duration / 3600000);
        const minutes = Math.floor((duration % 3600000) / 60000);
        const seconds = Math.floor((duration % 60000) / 1000);
        
        const formattedDuration = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        console.log(`Session duration: ${formattedDuration}, Data points: ${dataPointsCount}`);
    }
}

// Removed chart-related functions as they're no longer needed

function showError(message) {
    document.getElementById('errorMessage').textContent = message;
    document.getElementById('errorModal').classList.remove('hidden');
}

function closeErrorModal() {
    document.getElementById('errorModal').classList.add('hidden');
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
    }
    
    if (isMonitoring) {
        stopMonitoring();
    }
});
{% endblock %}